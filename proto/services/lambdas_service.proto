/*
  API Specification for the Decentraland Catalyst Server (BETA)

  A Catalyst is a Server that runs different services. These services currently work as the backbone for Decentraland and work in a decentralized network. The current specification details the following services: <br/><br/>- Archipelago <br/>- Content Server <br/>- Lambdas Service <br/> <br/>WARNING: We are working to close the version 1.0 of the Catalyst Protocol defined by this API. So far this is what we have and it's public but we are still working on refinement and during this process we may decided to deprecate or change some of the endpoints.

  The version of the OpenAPI document: 1.0

  Generated by OpenAPI Generator: https://openapi-generator.tech
*/

syntax = "proto3";

package openapitools.services.lambdasservice;

import "google/protobuf/empty.proto";
import public "models/entity.proto";
import public "models/erc721.proto";
import public "models/get_collections200_response.proto";
import public "models/get_emotes200_response.proto";
import public "models/get_third_party_wearables200_response.proto";
import public "models/get_wearables200_response.proto";
import public "models/hot_scenes_inner.proto";
import public "models/hot_scenes_inner_realms_inner.proto";
import public "models/lambdas_error.proto";
import public "models/lands_paginated.proto";
import public "models/names_paginated.proto";
import public "models/post_profiles.proto";
import public "models/profile.proto";
import public "models/servers_inner.proto";
import public "models/status_lambdas.proto";
import public "models/todo_object_mapping.proto";
import public "models/third_party_integrations.proto";
import public "models/wearables.proto";

service LambdasService {
  rpc GetAvatarDetails (GetAvatarDetailsRequest) returns (Profile);

  rpc GetAvatarsDetailsByPost (GetAvatarsDetailsByPostRequest) returns (GetAvatarsDetailsByPostResponse);

  rpc GetCollections (google.protobuf.Empty) returns (GetCollections200Response);

  rpc GetDenylistedUserNames (google.protobuf.Empty) returns (GetDenylistedUserNamesResponse);

  rpc GetEmotes (GetEmotesRequest) returns (GetEmotes200Response);

  rpc GetHotScenes (google.protobuf.Empty) returns (GetHotScenesResponse);

  rpc GetImage (GetImageRequest) returns (GetImageResponse);

  rpc GetLambdaStatus (google.protobuf.Empty) returns (StatusLambdas);

  rpc GetLands (GetLandsRequest) returns (LandsPaginated);

  rpc GetNames (GetNamesRequest) returns (NamesPaginated);

  rpc GetOutfits (GetOutfitsRequest) returns (Entity);

  rpc GetPois (google.protobuf.Empty) returns (GetPoisResponse);

  rpc GetRealms (google.protobuf.Empty) returns (GetRealmsResponse);

  rpc GetServers (google.protobuf.Empty) returns (GetServersResponse);

  rpc GetStandardErc721 (GetStandardErc721Request) returns (Erc721);

  rpc GetThirdPartyCollection (GetThirdPartyCollectionRequest) returns (GetThirdPartyWearables200Response);

  rpc GetThirdPartyIntegrations (google.protobuf.Empty) returns (ThirdPartyIntegrations);

  rpc GetThirdPartyWearables (GetThirdPartyWearablesRequest) returns (GetThirdPartyWearables200Response);

  rpc GetThumbnail (GetThumbnailRequest) returns (GetThumbnailResponse);

  rpc GetWearables (GetWearablesRequest) returns (GetWearables200Response);

  rpc SearchWearables (SearchWearablesRequest) returns (Wearables);

  rpc ValidateSignature (ValidateSignatureRequest) returns (TODO_OBJECT_MAPPING);

}

message GetAvatarDetailsRequest {
  // Ethereum address of the user
  string id = 1;

}

message GetAvatarsDetailsByPostRequest {
  // The body only has the `ids` property representing a list of Ethereum addresses
  PostProfiles postProfiles = 1;

}

message GetAvatarsDetailsByPostResponse {
  repeated Profile data = 1;
}

message GetDenylistedUserNamesResponse {
  repeated string data = 1;
}

message GetEmotesRequest {
  // Ethereum address from which you want to get the list of emotes
  string address = 1;
  // Third Party collection Id to filter emotes, if this param is not sent then the 3rd parties emotes are not shown. If it is sent, only the 3rd parties emotes are shown.
  string collectionId = 2;
  // If present, response will be extended with the entity data.
  bool includeEntities = 3;
  // The number of the requested page.
  string pageNum = 4;
  // The size of the requested page
  string pageSize = 5;

}

message GetHotScenesResponse {
  repeated HotScenesInner data = 1;
}

message GetImageRequest {
  // Uniform Resource Name (URN) that identifies the asset
  string urn = 1;

}

message GetImageResponse {
  string data = 1;
}

message GetLandsRequest {
  // Ethereum address from which you want to get the list of lands
  string address = 1;
  // The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
  string pageNum = 2;
  // The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
  string pageSize = 3;

}

message GetNamesRequest {
  // Ethereum address from which you want to get the list of names
  string address = 1;
  // The number of the requested page. It needs `pageSize` to be present to enable a paginated response.
  string pageNum = 2;
  // The size of the requested page. It needs `pageNum` to be present to enable a paginated response.
  string pageSize = 3;

}

message GetOutfitsRequest {
  // Ethereum address of the user
  string id = 1;

}

message GetPoisResponse {
  repeated string data = 1;
}

message GetRealmsResponse {
  repeated HotScenesInnerRealmsInner data = 1;
}

message GetServersResponse {
  repeated ServersInner data = 1;
}

message GetStandardErc721Request {
  // Ethereum chain ID:   ETHEREUM_MAINNET = 1   ETHEREUM_RINKEBY = 4   ETHEREUM_GOERLI = 5   ETHEREUM_KOVAN = 42   MATIC_MAINNET = 137   MATIC_MUMBAI = 80001
  string chainId = 1;
  // Hash of the Contract. This will be used to build the URN that identifies the NFT.
  string contract = 2;
  // Token Identifier
  string option = 3;
  // Optional rarity description that will be return as part of the NFT description common: 100000 uncommon: 10000 rare: 5000 epic: 1000 legendary: 100 mythic: 10 unique: 1
  string emission = 4;

}

message GetThirdPartyCollectionRequest {
  // Ethereum address from which you want to get the list of wearables
  string address = 1;
  // Third Party collection Id to filter wearables.
  string collectionId = 2;
  // The number of the requested page.
  string pageNum = 3;
  // The size of the requested page.
  string pageSize = 4;

}

message GetThirdPartyWearablesRequest {
  // Ethereum address from which you want to get the list of wearables
  string address = 1;
  // The number of the requested page.
  string pageNum = 2;
  // The size of the requested page.
  string pageSize = 3;

}

message GetThumbnailRequest {
  // Uniform Resource Name (URN) that identifies the asset
  string urn = 1;

}

message GetThumbnailResponse {
  string data = 1;
}

message GetWearablesRequest {
  // Ethereum address from which you want to get the list of wearables
  string address = 1;
  // If present, response will be extended with the entity data.
  bool includeEntities = 2;
  // If present, response will include the third-party wearables owned by the address. They will appear before other wearables if the response is paginated.
  bool includeThirdParty = 3;
  // The number of the requested page.
  string pageNum = 4;
  // The size of the requested page.
  string pageSize = 5;
  // Determines the field to be sort by. By default it will be by `transferredAt`. Possible values: `transferredAt` and `rarity`.
  string orderBy = 6;

}

message SearchWearablesRequest {
  // Lis of URNs that identify the collection. Maximum amount of ids allowed is 500.
  repeated string collectionId = 1;
  // List of wearables URNs to search. Maximum amount of ids allowed is 500.
  repeated string wearableId = 2;
  // Search text
  string textSearch = 3;
  // Limit the quantity of results that will be returned by the request. You can only request up to 500 results.
  int32 limit = 4;
  // The result will always be ordered by the local timestamp fields but in case of timestamp collisions, you can use the lastId field to filter the result
  string lastId = 5;

}

message ValidateSignatureRequest {
  // The body has 3 properties. The timestamp, the signedMessage that you wish to validate and the AuthChain. <br/>The structure of the AuthChain is described as follows: <br/>- The first element of the chain is the original signer, and the one who will be used to validate against the blockchain <br/>- The last element of the chain contains the EHash and a signature <br/>- In between are ephemeral keys that can be used for signing
  TODO_OBJECT_MAPPING body = 1;

}

